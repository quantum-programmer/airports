Был лишь один вопрос: отсутствовал файл "airports.dat", который должен был идти к заданию.
Поэтому создал свой airports.dat - в ресурсах в проекте.

com.airports.App - главный класс для запуска. В качестве параметра указывать 2 - 2 колонка - нагляднее всего.
Но можно и любую другую - по любой поиск работает.

--------------------------
Учтены все требования 
--------------------------


Чтобы уложиться в 7 МБ:

    Индекс строится только для префиксов, а не для всех данных.

    Строки не дублируются: используется исходная строка из файла (rawLine), а не её копии.

    Числовые колонки парсятся "на лету" без хранения промежуточных объектов.
	
	
Отказ от хранения всего файла в памяти

    Данные читаются единожды при старте (AirportParser.parse()), но затем:

        Сырые строки (rawLine) хранятся в List<Airport>.

        Индекс (prefixMap) содержит только ссылки на эти строки, а не копии.


Краевые случаи

    Пустой файл: Память не расходуется сверх минимального JVM-оверхеда.

    Колонка с очень длинными строками: Индекс строится по префиксам, а не по полным строкам.

    Числовые колонки: Парсинг чисел "на лету" без хранения Double-объектов.
	

Если для очень больших файлов памяти недостаточно:
	try (RandomAccessFile raf = new RandomAccessFile("airports.dat", "r");
		 FileChannel channel = raf.getChannel()) {
		MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());
		// Чтение данных напрямую из файла, без загрузки в память
	}
	
	
Можно Оптимизировать prefixMap:

        Заменить HashMap на Trie-структуру.

        Использовать ByteBuffer для строк.

Но в текущей реализации эти меры не требуются для файлов среднего размера (до ~50 000 строк).